{"version":3,"file":"static/js/646.3148898c.chunk.js","mappings":"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","sources":["../node_modules/@tsparticles/updater-out-modes/browser/BounceOutMode.js","../node_modules/@tsparticles/updater-out-modes/browser/Utils.js","../node_modules/@tsparticles/updater-out-modes/browser/DestroyOutMode.js","../node_modules/@tsparticles/updater-out-modes/browser/NoneOutMode.js","../node_modules/@tsparticles/updater-out-modes/browser/OutOutMode.js","../node_modules/@tsparticles/updater-out-modes/browser/OutOfCanvasUpdater.js"],"sourcesContent":["import { calculateBounds, } from \"@tsparticles/engine\";\nimport { bounceHorizontal, bounceVertical } from \"./Utils.js\";\nexport class BounceOutMode {\n    constructor(container) {\n        this.container = container;\n        this.modes = [\n            \"bounce\",\n            \"split\",\n        ];\n    }\n    update(particle, direction, delta, outMode) {\n        if (!this.modes.includes(outMode)) {\n            return;\n        }\n        const container = this.container;\n        let handled = false;\n        for (const [, plugin] of container.plugins) {\n            if (plugin.particleBounce !== undefined) {\n                handled = plugin.particleBounce(particle, delta, direction);\n            }\n            if (handled) {\n                break;\n            }\n        }\n        if (handled) {\n            return;\n        }\n        const pos = particle.getPosition(), offset = particle.offset, size = particle.getRadius(), bounds = calculateBounds(pos, size), canvasSize = container.canvas.size;\n        bounceHorizontal({ particle, outMode, direction, bounds, canvasSize, offset, size });\n        bounceVertical({ particle, outMode, direction, bounds, canvasSize, offset, size });\n    }\n}\n","import { getRangeValue } from \"@tsparticles/engine\";\nconst minVelocity = 0, boundsMin = 0;\nexport function bounceHorizontal(data) {\n    if ((data.outMode !== \"bounce\" && data.outMode !== \"split\") ||\n        (data.direction !== \"left\" && data.direction !== \"right\")) {\n        return;\n    }\n    if (data.bounds.right < boundsMin && data.direction === \"left\") {\n        data.particle.position.x = data.size + data.offset.x;\n    }\n    else if (data.bounds.left > data.canvasSize.width && data.direction === \"right\") {\n        data.particle.position.x = data.canvasSize.width - data.size - data.offset.x;\n    }\n    const velocity = data.particle.velocity.x;\n    let bounced = false;\n    if ((data.direction === \"right\" &&\n        data.bounds.right >= data.canvasSize.width &&\n        velocity > minVelocity) ||\n        (data.direction === \"left\" && data.bounds.left <= boundsMin && velocity < minVelocity)) {\n        const newVelocity = getRangeValue(data.particle.options.bounce.horizontal.value);\n        data.particle.velocity.x *= -newVelocity;\n        bounced = true;\n    }\n    if (!bounced) {\n        return;\n    }\n    const minPos = data.offset.x + data.size;\n    if (data.bounds.right >= data.canvasSize.width && data.direction === \"right\") {\n        data.particle.position.x = data.canvasSize.width - minPos;\n    }\n    else if (data.bounds.left <= boundsMin && data.direction === \"left\") {\n        data.particle.position.x = minPos;\n    }\n    if (data.outMode === \"split\") {\n        data.particle.destroy();\n    }\n}\nexport function bounceVertical(data) {\n    if ((data.outMode !== \"bounce\" && data.outMode !== \"split\") ||\n        (data.direction !== \"bottom\" && data.direction !== \"top\")) {\n        return;\n    }\n    if (data.bounds.bottom < boundsMin && data.direction === \"top\") {\n        data.particle.position.y = data.size + data.offset.y;\n    }\n    else if (data.bounds.top > data.canvasSize.height && data.direction === \"bottom\") {\n        data.particle.position.y = data.canvasSize.height - data.size - data.offset.y;\n    }\n    const velocity = data.particle.velocity.y;\n    let bounced = false;\n    if ((data.direction === \"bottom\" &&\n        data.bounds.bottom >= data.canvasSize.height &&\n        velocity > minVelocity) ||\n        (data.direction === \"top\" && data.bounds.top <= boundsMin && velocity < minVelocity)) {\n        const newVelocity = getRangeValue(data.particle.options.bounce.vertical.value);\n        data.particle.velocity.y *= -newVelocity;\n        bounced = true;\n    }\n    if (!bounced) {\n        return;\n    }\n    const minPos = data.offset.y + data.size;\n    if (data.bounds.bottom >= data.canvasSize.height && data.direction === \"bottom\") {\n        data.particle.position.y = data.canvasSize.height - minPos;\n    }\n    else if (data.bounds.top <= boundsMin && data.direction === \"top\") {\n        data.particle.position.y = minPos;\n    }\n    if (data.outMode === \"split\") {\n        data.particle.destroy();\n    }\n}\n","import { Vector, getDistances, isPointInside, } from \"@tsparticles/engine\";\nconst minVelocity = 0;\nexport class DestroyOutMode {\n    constructor(container) {\n        this.container = container;\n        this.modes = [\"destroy\"];\n    }\n    update(particle, direction, _delta, outMode) {\n        if (!this.modes.includes(outMode)) {\n            return;\n        }\n        const container = this.container;\n        switch (particle.outType) {\n            case \"normal\":\n            case \"outside\":\n                if (isPointInside(particle.position, container.canvas.size, Vector.origin, particle.getRadius(), direction)) {\n                    return;\n                }\n                break;\n            case \"inside\": {\n                const { dx, dy } = getDistances(particle.position, particle.moveCenter), { x: vx, y: vy } = particle.velocity;\n                if ((vx < minVelocity && dx > particle.moveCenter.radius) ||\n                    (vy < minVelocity && dy > particle.moveCenter.radius) ||\n                    (vx >= minVelocity && dx < -particle.moveCenter.radius) ||\n                    (vy >= minVelocity && dy < -particle.moveCenter.radius)) {\n                    return;\n                }\n                break;\n            }\n        }\n        container.particles.remove(particle, undefined, true);\n    }\n}\n","import { Vector, isPointInside, } from \"@tsparticles/engine\";\nconst minVelocity = 0;\nexport class NoneOutMode {\n    constructor(container) {\n        this.container = container;\n        this.modes = [\"none\"];\n    }\n    update(particle, direction, delta, outMode) {\n        if (!this.modes.includes(outMode)) {\n            return;\n        }\n        if ((particle.options.move.distance.horizontal &&\n            (direction === \"left\" || direction === \"right\")) ??\n            (particle.options.move.distance.vertical &&\n                (direction === \"top\" || direction === \"bottom\"))) {\n            return;\n        }\n        const gravityOptions = particle.options.move.gravity, container = this.container, canvasSize = container.canvas.size, pRadius = particle.getRadius();\n        if (!gravityOptions.enable) {\n            if ((particle.velocity.y > minVelocity && particle.position.y <= canvasSize.height + pRadius) ||\n                (particle.velocity.y < minVelocity && particle.position.y >= -pRadius) ||\n                (particle.velocity.x > minVelocity && particle.position.x <= canvasSize.width + pRadius) ||\n                (particle.velocity.x < minVelocity && particle.position.x >= -pRadius)) {\n                return;\n            }\n            if (!isPointInside(particle.position, container.canvas.size, Vector.origin, pRadius, direction)) {\n                container.particles.remove(particle);\n            }\n        }\n        else {\n            const position = particle.position;\n            if ((!gravityOptions.inverse &&\n                position.y > canvasSize.height + pRadius &&\n                direction === \"bottom\") ||\n                (gravityOptions.inverse && position.y < -pRadius && direction === \"top\")) {\n                container.particles.remove(particle);\n            }\n        }\n    }\n}\n","import { Vector, calculateBounds, getDistances, getRandom, isPointInside, randomInRange, } from \"@tsparticles/engine\";\nconst minVelocity = 0, minDistance = 0;\nexport class OutOutMode {\n    constructor(container) {\n        this.container = container;\n        this.modes = [\"out\"];\n    }\n    update(particle, direction, delta, outMode) {\n        if (!this.modes.includes(outMode)) {\n            return;\n        }\n        const container = this.container;\n        switch (particle.outType) {\n            case \"inside\": {\n                const { x: vx, y: vy } = particle.velocity;\n                const circVec = Vector.origin;\n                circVec.length = particle.moveCenter.radius;\n                circVec.angle = particle.velocity.angle + Math.PI;\n                circVec.addTo(Vector.create(particle.moveCenter));\n                const { dx, dy } = getDistances(particle.position, circVec);\n                if ((vx <= minVelocity && dx >= minDistance) ||\n                    (vy <= minVelocity && dy >= minDistance) ||\n                    (vx >= minVelocity && dx <= minDistance) ||\n                    (vy >= minVelocity && dy <= minDistance)) {\n                    return;\n                }\n                particle.position.x = Math.floor(randomInRange({\n                    min: 0,\n                    max: container.canvas.size.width,\n                }));\n                particle.position.y = Math.floor(randomInRange({\n                    min: 0,\n                    max: container.canvas.size.height,\n                }));\n                const { dx: newDx, dy: newDy } = getDistances(particle.position, particle.moveCenter);\n                particle.direction = Math.atan2(-newDy, -newDx);\n                particle.velocity.angle = particle.direction;\n                break;\n            }\n            default: {\n                if (isPointInside(particle.position, container.canvas.size, Vector.origin, particle.getRadius(), direction)) {\n                    return;\n                }\n                switch (particle.outType) {\n                    case \"outside\": {\n                        particle.position.x =\n                            Math.floor(randomInRange({\n                                min: -particle.moveCenter.radius,\n                                max: particle.moveCenter.radius,\n                            })) + particle.moveCenter.x;\n                        particle.position.y =\n                            Math.floor(randomInRange({\n                                min: -particle.moveCenter.radius,\n                                max: particle.moveCenter.radius,\n                            })) + particle.moveCenter.y;\n                        const { dx, dy } = getDistances(particle.position, particle.moveCenter);\n                        if (particle.moveCenter.radius) {\n                            particle.direction = Math.atan2(dy, dx);\n                            particle.velocity.angle = particle.direction;\n                        }\n                        break;\n                    }\n                    case \"normal\": {\n                        const warp = particle.options.move.warp, canvasSize = container.canvas.size, newPos = {\n                            bottom: canvasSize.height + particle.getRadius() + particle.offset.y,\n                            left: -particle.getRadius() - particle.offset.x,\n                            right: canvasSize.width + particle.getRadius() + particle.offset.x,\n                            top: -particle.getRadius() - particle.offset.y,\n                        }, sizeValue = particle.getRadius(), nextBounds = calculateBounds(particle.position, sizeValue);\n                        if (direction === \"right\" &&\n                            nextBounds.left > canvasSize.width + particle.offset.x) {\n                            particle.position.x = newPos.left;\n                            particle.initialPosition.x = particle.position.x;\n                            if (!warp) {\n                                particle.position.y = getRandom() * canvasSize.height;\n                                particle.initialPosition.y = particle.position.y;\n                            }\n                        }\n                        else if (direction === \"left\" && nextBounds.right < -particle.offset.x) {\n                            particle.position.x = newPos.right;\n                            particle.initialPosition.x = particle.position.x;\n                            if (!warp) {\n                                particle.position.y = getRandom() * canvasSize.height;\n                                particle.initialPosition.y = particle.position.y;\n                            }\n                        }\n                        if (direction === \"bottom\" &&\n                            nextBounds.top > canvasSize.height + particle.offset.y) {\n                            if (!warp) {\n                                particle.position.x = getRandom() * canvasSize.width;\n                                particle.initialPosition.x = particle.position.x;\n                            }\n                            particle.position.y = newPos.top;\n                            particle.initialPosition.y = particle.position.y;\n                        }\n                        else if (direction === \"top\" && nextBounds.bottom < -particle.offset.y) {\n                            if (!warp) {\n                                particle.position.x = getRandom() * canvasSize.width;\n                                particle.initialPosition.x = particle.position.x;\n                            }\n                            particle.position.y = newPos.bottom;\n                            particle.initialPosition.y = particle.position.y;\n                        }\n                        break;\n                    }\n                }\n                break;\n            }\n        }\n    }\n}\n","import { BounceOutMode } from \"./BounceOutMode.js\";\nimport { DestroyOutMode } from \"./DestroyOutMode.js\";\nimport { NoneOutMode } from \"./NoneOutMode.js\";\nimport { OutOutMode } from \"./OutOutMode.js\";\nconst checkOutMode = (outModes, outMode) => {\n    return (outModes.default === outMode ||\n        outModes.bottom === outMode ||\n        outModes.left === outMode ||\n        outModes.right === outMode ||\n        outModes.top === outMode);\n};\nexport class OutOfCanvasUpdater {\n    constructor(container) {\n        this._updateOutMode = (particle, delta, outMode, direction) => {\n            for (const updater of this.updaters) {\n                updater.update(particle, direction, delta, outMode);\n            }\n        };\n        this.container = container;\n        this.updaters = [];\n    }\n    init(particle) {\n        this.updaters = [];\n        const outModes = particle.options.move.outModes;\n        if (checkOutMode(outModes, \"bounce\")) {\n            this.updaters.push(new BounceOutMode(this.container));\n        }\n        else if (checkOutMode(outModes, \"out\")) {\n            this.updaters.push(new OutOutMode(this.container));\n        }\n        else if (checkOutMode(outModes, \"destroy\")) {\n            this.updaters.push(new DestroyOutMode(this.container));\n        }\n        else if (checkOutMode(outModes, \"none\")) {\n            this.updaters.push(new NoneOutMode(this.container));\n        }\n    }\n    isEnabled(particle) {\n        return !particle.destroyed && !particle.spawning;\n    }\n    update(particle, delta) {\n        const outModes = particle.options.move.outModes;\n        this._updateOutMode(particle, delta, outModes.bottom ?? outModes.default, \"bottom\");\n        this._updateOutMode(particle, delta, outModes.left ?? outModes.default, \"left\");\n        this._updateOutMode(particle, delta, outModes.right ?? outModes.default, \"right\");\n        this._updateOutMode(particle, delta, outModes.top ?? outModes.default, \"top\");\n    }\n}\n"],"names":["BounceOutMode","constructor","container","this","modes","update","particle","direction","delta","outMode","includes","handled","plugin","plugins","undefined","particleBounce","pos","getPosition","offset","size","getRadius","bounds","calculateBounds","canvasSize","canvas","data","right","position","x","left","width","velocity","bounced","newVelocity","getRangeValue","options","bounce","horizontal","value","minPos","destroy","bounceHorizontal","bottom","y","top","height","vertical","bounceVertical","DestroyOutMode","_delta","outType","isPointInside","Vector","origin","dx","dy","getDistances","moveCenter","vx","vy","radius","particles","remove","NoneOutMode","_ref","move","distance","gravityOptions","gravity","pRadius","enable","inverse","OutOutMode","circVec","length","angle","Math","PI","addTo","create","floor","randomInRange","min","max","newDx","newDy","atan2","warp","newPos","sizeValue","nextBounds","initialPosition","getRandom","checkOutMode","outModes","default","OutOfCanvasUpdater","_updateOutMode","updater","updaters","init","push","isEnabled","destroyed","spawning","_outModes$bottom","_outModes$left","_outModes$right","_outModes$top"],"sourceRoot":""}